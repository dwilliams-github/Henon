/* | ++ | | Henon project: dialog box routines | | History: | 		Sep 30, 1992	- Copied from Henon.c | | (c) Copyright 1992 David C. Williams | | --*/#include <stdlib.h>#include <string.h>#include <stdio.h>#include <math.h>#include <MacHeaders>#include "hendef.h"		pascal void OutlineButUser( dialog, itemNo )	DialogPtr	dialog;	int			itemNo;/* | User dialog item window for outlining buttons. The user item | associated with the button to outline must have a number = buttonNo + 10. | Notes: |	 * Color may not be correctly supported in this routine*/{	PenState	savePen;	short		itemType;	Handle		itemHandle;	Rect		itemBox;		/* Get current pen state, to be returned later */		GetPenState( &savePen );		/* Get info on associated button item (this item - 10) */		GetDItem( dialog, itemNo-10, &itemType, &itemHandle, &itemBox );		/* Draw an appropriate rectangle around the item */		PenNormal();	PenSize( 3, 3 );	InsetRect( &itemBox, -4, -4 );	FrameRoundRect( &itemBox, 16, 16 );		/* Put things back */		SetPenState( &savePen );	return;}				void OutlineButton( dialog, itemNo )	DialogPtr	dialog;	int			itemNo;/* | Install outline button user item to outline button with item number itemNo. | A user control device must exist with number itemNo + 10.*/{	short	itemType;	Handle	itemHandle;	Rect	itemBox;		/* Get info on the target button */		GetDItem( dialog, itemNo, &itemType, &itemHandle, &itemBox );		/* Make space for the outline */		InsetRect( &itemBox, -8, -8 );		/* Set associated user control device. 'userItem' is a MAC constant. */		SetDItem( dialog, itemNo+10, (short)userItem, (Handle)OutlineButUser, &itemBox );	return;}	pascal void DialogBoxUser( dialog, itemNo )	DialogPtr	dialog;	int			itemNo;/* | User dialog item for draw boxes.  | Notes: |	 * Color may not be correctly supported in this routine*/{	PenState	savePen;	short		itemType;	Handle		itemHandle;	Rect		itemBox;		/* Get current pen state, to be returned later */		GetPenState( &savePen );		/* Get info on this item */		GetDItem( dialog, itemNo, &itemType, &itemHandle, &itemBox );		/* Draw the rectangle */		PenNormal();	FrameRect( &itemBox );		/* Put things back */		SetPenState( &savePen );	return;}				void DialogBox( dialog, itemNo )	DialogPtr	dialog;	int			itemNo;/* | Install user item to draw a box.*/{	short	itemType;	Handle	itemHandle;	Rect	itemBox;		/* Get info on the target button */		GetDItem( dialog, itemNo, &itemType, &itemHandle, &itemBox );		/* Set associated user control device. 'userItem' is a MAC constant. */		SetDItem( dialog, itemNo, userItem, (Handle)DialogBoxUser, &itemBox );	return;}	SetIntString( strHndl, number )	ControlHandle	strHndl;	int				number;/* | Set a dialog text item to an integer string. | Parameters: | 		strHndl		- (in) Handle to string |		number		- (in) Integer number to write to string*/{	Str255	formString;		sprintf( (char *)formString, "%d", number );	CtoPstr( (char *)formString );	SetIText( (Handle)strHndl, formString );		return;}int	GetIntString( strHndl, number )	ControlHandle	strHndl;	int				*number;/* | Return the integer number in a text item of a dialog box. | returns FALSE (0) if the item has illegal syntax*/{	Str255	formString;	GetIText( (Handle)strHndl, formString );	PtoCstr( formString );	return( sscanf( (char *)formString, "%d", number ) );}		SetFloatString( strHndl, number )	ControlHandle	strHndl;	double			number;/* | Set a dialog text item to a floating point string. | Parameters: | 		strHndl		- (in) Handle to string |		number		- (in) floating point number to write to string*/{	Str255	formString;		sprintf( (char *)formString, "%-14.8g", number );	CtoPstr( (char *)formString );	SetIText( (Handle)strHndl, formString );		return;}void SscanBugFix( numstr, number )	char 	*numstr;	double	*number;{	char 	*to, *from;		/* Search string for bug condition: */		if (!(to = strpbrk( numstr, "0123456789" )) ) return;	if(*to!='0') return;		while (*to=='0') to++;		if ( (*to=='.') && (*(to+1)=='0') ) {		for(from=++to+1;*from=='0';from++);			*number = (*number)*pow( (double)10, (double)(to-from) );	}		return;}int	GetFloatString( strHndl, number )	ControlHandle	strHndl;	double			*number;/* | Return the floating point number in a text item of a dialog box. | returns FALSE (0) if the item has illegal syntax*/{	Str255	formString;	int		status;	GetIText( (Handle )strHndl, formString );	PtoCstr( formString );	status = sscanf( (char *)formString, "%lf", number );/*	SscanBugFix( (char *)formString, number );						No longer necessary? */		return(status);}#define		COORD_DIAL		128#define		CD_CANCEL		1#define		CD_USENEW		2#define		CD_BOTTOM		8#define		CD_LEFT			9#define		CD_SIZE			10#define		CD_NEWBOT		12#define		CD_NEWLEFT		13#define		CD_NEWSIZE		14#define		CD_USEPREV		17#define		CD_PREVBOT		18#define		CD_PREVLEFT		19#define		CD_PREVSIZE		20#define		CD_RESET		26int CoordDialog( henonView )	HenonViewType	*henonView; /* | Handle "New Scale" dialog box. | Parameters: | 		henonView	- (in) Henon view record | Return value: |		non zero (true) if the Henon picture should be redrawn*/{	DialogPtr		coordDial;	short			itemHit,					itemType;	ControlHandle	staticStr,					newLeftStr,					newBotStr,					newSizeStr;						ScaleType		*currScale,					*newScale,					*prevScale;	Rect			box;						/* Get pointers to current, previous, and new scales */		currScale = henonView->scales + henonView->currScale;		newScale  = currScale + 1;	prevScale = henonView->currScale ? currScale - 1 : 0;				/* 	 | If no valid new scale exists, copy the current scale into	 | its space (if there is any) 	*/	   	if (newScale > henonView->scales + MAX_SCALES) {		newScale = 0;	}	else if (!henonView->validNewScale) {		*newScale = *currScale;	}	/* Make our dialog window */	coordDial = GetNewDialog( COORD_DIAL, 0L, (WindowPtr)(-1) );		/* Outline the 'Cancel' button */		OutlineButton( coordDial, CD_CANCEL );		/* Set the scale items */		GetDItem( coordDial, CD_BOTTOM, &itemType, (Handle *)&staticStr, &box );	SetFloatString( staticStr, currScale->bot ); 				GetDItem( coordDial, CD_LEFT,   &itemType, (Handle *)&staticStr, &box );	SetFloatString( staticStr, currScale->left ); 			GetDItem( coordDial, CD_SIZE,   &itemType, (Handle *)&staticStr, &box );	SetFloatString( staticStr, currScale->size ); 		/* Set previous scale item */		if (prevScale) {		GetDItem( coordDial, CD_PREVBOT,  &itemType, (Handle *)&staticStr, &box );		SetFloatString( staticStr, prevScale->bot ); 		HiliteControl( staticStr, 0 );					GetDItem( coordDial, CD_PREVLEFT, &itemType, (Handle *)&staticStr, &box );		SetFloatString( staticStr, prevScale->left ); 		HiliteControl( staticStr, 0 );				GetDItem( coordDial, CD_PREVSIZE, &itemType, (Handle *)&staticStr, &box );		SetFloatString( staticStr, prevScale->size ); 		HiliteControl( staticStr, 0 );	}	else {		ControlHandle prev;				GetDItem( coordDial, CD_USEPREV, &itemType, (Handle *)&prev, &box );			HiliteControl( prev, 255 );	}		/* Set the new scale item, if it exists */		if (newScale) {		GetDItem( coordDial, CD_NEWBOT,  &itemType, (Handle *)&newBotStr,  &box );		SetFloatString( newBotStr,  newScale->bot ); 			GetDItem( coordDial, CD_NEWLEFT, &itemType, (Handle *)&newLeftStr, &box );		SetFloatString( newLeftStr, newScale->left ); 			GetDItem( coordDial, CD_NEWSIZE, &itemType, (Handle *)&newSizeStr, &box );		SetFloatString( newSizeStr, newScale->size ); 	}	else {		ControlHandle	last;			GetDItem( coordDial, CD_USENEW, &itemType, (Handle *)&last, &box );			HiliteControl( last, 255 );	}	/* Our dialog window is complete: make it appear */		ShowWindow( coordDial );		/* Call model dialog handler until 'Cancel', 'UsePrev', or 'UseNew' hit */	for(;;) {		ModalDialog( 0L, &itemHit );		if (itemHit==CD_CANCEL) {			break;		}		if (itemHit==CD_RESET) {			static ScaleType defScale = DEFAULT_SCALE; 					/* Reset scales to default */					henonView->currScale = 0;			henonView->validNewScale = 0;			henonView->scales[0] = defScale;			break;		}		if (itemHit==CD_USEPREV) {					/* 'Use Prev' pressed: revert to previous scale */					henonView->currScale--;			henonView->validNewScale = 0;			break;		}		if (itemHit==CD_USENEW) {					/* 'Use new' pressed: is there space? */						if (newScale == 0) continue;						/* Read in values */				if (!GetFloatString( newBotStr, &newScale->bot )) {							CautionAlert( BADFLOAT_ALERT, 0 );				SelIText( coordDial, CD_NEWBOT, 0, 32767 );				newScale = 0;				continue;			}						if (!GetFloatString( newLeftStr, &newScale->left )) {							CautionAlert( BADFLOAT_ALERT, 0 );				SelIText( coordDial, CD_NEWLEFT, 0, 32767 );				newScale = 0;				continue;			}							if (!GetFloatString( newSizeStr, &newScale->size )) {							CautionAlert( BADFLOAT_ALERT, 0 );				SelIText( coordDial, CD_NEWSIZE, 0, 32767 );				newScale = 0;				continue;			}							henonView->currScale++;			henonView->validNewScale = 0;			break;		}	} 		/* We're done: dispose of dialog window */		DisposDialog( coordDial );		return(itemHit != CD_CANCEL );}#define		PARAM_DIAL	129#define		PD_OKAY		1#define		PD_CANCEL	2#define		PD_XSTART	3#define		PD_YSTART	4#define		PD_PARM1	5#define		PD_PARM2	6#define		PD_PARM3	7#define		PD_RANDOM	8#define		PD_OUTLINE1	14#define		PD_OUTLINE2	16#define		PD_DEFPARM	15int ParamDialog( henonView )	HenonViewType	*henonView; {	DialogPtr		paramDial;	short			itemHit,					itemType;	Rect			box;						typedef struct {		int				id;		ControlHandle	str;		double			new;		double			*save;	} Parm;		Parm	parms[] = { {PD_XSTART},{PD_YSTART},{PD_PARM1},{PD_PARM2},{PD_PARM3} };	Parm	*oneParm;		#define NUMPARM   (sizeof(parms)/sizeof(Parm))		/* Make our dialog window */	paramDial = GetNewDialog( PARAM_DIAL, 0L, (WindowPtr)(-1) );		/* Outline the 'Okay' button */		OutlineButton( paramDial, PD_OKAY );		/* Define box user items */		DialogBox( paramDial, PD_OUTLINE1 );	DialogBox( paramDial, PD_OUTLINE2 );		/* Set the parameter items */		parms[0].save = &henonView->xstart;	parms[1].save = &henonView->ystart;	parms[2].save = &henonView->parm1;	parms[3].save = &henonView->parm2;	parms[4].save = &henonView->parm3;		oneParm = parms;	do {		GetDItem( paramDial, oneParm->id, &itemType, (Handle *)&oneParm->str, &box );		SetFloatString( oneParm->str, *oneParm->save );	} while(++oneParm < parms + NUMPARM);		/* Our dialog window is complete: make it appear */		ShowWindow( paramDial );		/* Call model dialog handler until 'cancel' or 'okay' hit */	for(;;) {		ModalDialog( 0L, &itemHit );		if (itemHit==PD_CANCEL) {			DisposDialog( paramDial );			return(0);		}				if (itemHit==PD_RANDOM) {					/* Choose new random Xstart, Ystart, and add it to the dialog window */						oneParm = parms;			do {				oneParm->new = ( (double)Random() )/32767.0;				SetFloatString( oneParm->str, oneParm->new );			} while (++oneParm < parms + 2);		}		else if (itemHit==PD_DEFPARM) {					/* Assign default parameters */						SetFloatString( parms[2].str, DEF_PARM1 );			SetFloatString( parms[3].str, DEF_PARM2 );			SetFloatString( parms[4].str, DEF_PARM3 );		}		else if (itemHit==PD_OKAY) {					/* 'OKAY' was hit: convert text strings in numbers */			oneParm = parms;			for(;;) {				if (!GetFloatString( oneParm->str, &oneParm->new )) {								CautionAlert( BADFLOAT_ALERT, 0 );					SelIText( paramDial, oneParm->id, 0, 32767 );					break;				}				if (++oneParm >= parms + NUMPARM) {					while (--oneParm >= parms) *oneParm->save = oneParm->new;									DisposDialog( paramDial );					return(1);				}			}		}   /* Item hit */	}   /* Event loop */}#define		NUM_DIAL	130#define		ND_CANCEL	1#define		ND_OKAY		2#define		ND_NEW		3#define		ND_CURR		4void NumberDialog( henonView )	HenonViewType	*henonView;{	DialogPtr		numDial;	short			itemHit,					itemType;	ControlHandle	currStr,					newStr;	Rect			box;	/* Make our dialog window */	numDial = GetNewDialog( NUM_DIAL, 0L, (WindowPtr)(-1) );		/* Outline the 'Cancel' button */		OutlineButton( numDial, ND_CANCEL );		/* Set the parameter items */		GetDItem( numDial, ND_CURR, &itemType, (Handle *)&currStr, &box );	SetIntString( currStr, 222 ); 				GetDItem( numDial, ND_NEW,  &itemType, (Handle *)&newStr, &box );	SetIntString( newStr,  222 );	SelIText( numDial, ND_NEW, 0, 32767 );			/* Our dialog window is complete: make it appear */		ShowWindow( numDial );		/* Call model dialog handler until 'cancel' or 'okay' hit */	for(;;) {		ModalDialog( 0L, &itemHit );		if (itemHit==ND_CANCEL) break;		else if (itemHit==ND_OKAY) {			break;		}	} 		/* We're done: dispose of dialog window */		DisposDialog( numDial );	return;}